import { randomBytes } from "node:crypto";
import { existsSync } from "node:fs";
import { copyFile, mkdir, readFile, writeFile } from "node:fs/promises";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { $ } from "bun";

// Get directory of this file (works in both Bun and Node.js)
const __dirname =
  typeof import.meta.dir === "string" ? import.meta.dir : dirname(fileURLToPath(import.meta.url));

// Project root is where the user runs the command (current working directory)
const PROJECT_ROOT = process.cwd();
const DOCKER_DIR = join(PROJECT_ROOT, "docker/n8n");

// Templates location depends on whether running from source or built package
// - Source: packages/installer/src/services/ -> ../../templates
// - Built:  packages/installer/dist/         -> ../templates
function getTemplateDir(): string {
  // Try built package location first (../templates from dist/)
  const builtPath = join(__dirname, "../templates");
  if (existsSync(builtPath)) {
    return builtPath;
  }
  // Fall back to source location (../../templates from src/services/)
  return join(__dirname, "../../templates");
}

const TEMPLATE_DIR = getTemplateDir();

export interface N8nConfig {
  encryptionKey: string;
  host: string;
  port: number;
  protocol: string;
  webhookUrl?: string;
}

export interface TunnelConfig {
  apiToken: string;
  accountId: string;
  zoneId: string;
  zoneName: string;
  tunnelId: string;
  tunnelName: string;
  tunnelToken: string;
  hostname: string;
  dnsRecordId: string;
}

/**
 * Generate a cryptographically secure encryption key (64 hex characters)
 */
export function generateEncryptionKey(): string {
  return randomBytes(32).toString("hex");
}

/**
 * Read encryption key from existing n8n_data volume if it exists.
 * This prevents encryption key mismatch when reinstalling with existing data.
 */
export async function getExistingEncryptionKey(): Promise<string | null> {
  try {
    const result =
      await $`docker run --rm -v n8n_data:/data alpine cat /data/config 2>/dev/null`.quiet();
    const config = JSON.parse(result.text());
    if (config.encryptionKey && typeof config.encryptionKey === "string") {
      return config.encryptionKey;
    }
  } catch {
    // Volume doesn't exist or no config file
  }
  return null;
}

/**
 * Create the .env file with n8n configuration
 */
export async function createEnvFile(config: N8nConfig): Promise<void> {
  const envContent = `# n8n Configuration
# Generated by n8n-local-deploy installer
# DO NOT COMMIT THIS FILE

N8N_HOST=${config.host}
N8N_PORT=${config.port}
N8N_PROTOCOL=${config.protocol}
N8N_ENCRYPTION_KEY=${config.encryptionKey}
`;

  const envPath = join(DOCKER_DIR, ".env");

  // Ensure directory exists
  await mkdir(DOCKER_DIR, { recursive: true });

  // Write env file with restricted permissions
  await writeFile(envPath, envContent, { mode: 0o600 });
}

/**
 * Copy docker-compose.yml template to docker/n8n directory
 */
export async function copyDockerCompose(): Promise<void> {
  const templatePath = join(TEMPLATE_DIR, "docker-compose.yml");
  const targetPath = join(DOCKER_DIR, "docker-compose.yml");

  // Ensure directory exists
  await mkdir(DOCKER_DIR, { recursive: true });

  await copyFile(templatePath, targetPath);
}

/**
 * Read the existing .env file if it exists
 */
export async function readEnvFile(): Promise<N8nConfig | null> {
  const envPath = join(DOCKER_DIR, ".env");

  if (!existsSync(envPath)) {
    return null;
  }

  const content = await readFile(envPath, "utf-8");
  const lines = content.split("\n");

  const config: Partial<N8nConfig> = {};

  for (const line of lines) {
    const [key, value] = line.split("=");
    if (key === "N8N_HOST") config.host = value;
    if (key === "N8N_PORT") config.port = parseInt(value, 10);
    if (key === "N8N_PROTOCOL") config.protocol = value;
    if (key === "N8N_ENCRYPTION_KEY") config.encryptionKey = value;
  }

  if (config.encryptionKey && config.host && config.port && config.protocol) {
    return config as N8nConfig;
  }

  return null;
}

/**
 * Check if docker-compose.yml exists in the docker directory
 */
export function dockerComposeExists(): boolean {
  return existsSync(join(DOCKER_DIR, "docker-compose.yml"));
}

/**
 * Check if .env file exists
 */
export function envFileExists(): boolean {
  return existsSync(join(DOCKER_DIR, ".env"));
}

/**
 * Get the path to the docker directory
 */
export function getDockerDir(): string {
  return DOCKER_DIR;
}

/**
 * Create default configuration
 */
export function createDefaultConfig(): N8nConfig {
  return {
    encryptionKey: generateEncryptionKey(),
    host: "localhost",
    port: 8443,
    protocol: "https",
  };
}

/**
 * Create configuration with tunnel (external access)
 */
export function createTunnelConfig(hostname: string): N8nConfig {
  return {
    encryptionKey: generateEncryptionKey(),
    host: hostname,
    port: 8443,
    protocol: "https",
    webhookUrl: `https://${hostname}/`,
  };
}

/**
 * Create the .env file with tunnel configuration
 * FR-1.4: Store token securely in .env file with 600 permissions
 */
export async function createTunnelEnvFile(
  config: N8nConfig,
  tunnelConfig: TunnelConfig,
): Promise<void> {
  const envContent = `# n8n Configuration with Cloudflare Tunnel
# Generated by n8n-local-deploy installer
# DO NOT COMMIT THIS FILE

# n8n Settings
N8N_HOST=${config.host}
N8N_PORT=${config.port}
N8N_PROTOCOL=${config.protocol}
N8N_ENCRYPTION_KEY=${config.encryptionKey}
WEBHOOK_URL=${config.webhookUrl}

# Cloudflare Tunnel Settings
CLOUDFLARE_API_TOKEN=${tunnelConfig.apiToken}
CLOUDFLARE_ACCOUNT_ID=${tunnelConfig.accountId}
CLOUDFLARE_ZONE_ID=${tunnelConfig.zoneId}
CLOUDFLARE_ZONE_NAME=${tunnelConfig.zoneName}
CLOUDFLARE_TUNNEL_ID=${tunnelConfig.tunnelId}
CLOUDFLARE_TUNNEL_NAME=${tunnelConfig.tunnelName}
CLOUDFLARE_TUNNEL_TOKEN=${tunnelConfig.tunnelToken}
CLOUDFLARE_HOSTNAME=${tunnelConfig.hostname}
CLOUDFLARE_DNS_RECORD_ID=${tunnelConfig.dnsRecordId}
`;

  const envPath = join(DOCKER_DIR, ".env");

  // Ensure directory exists
  await mkdir(DOCKER_DIR, { recursive: true });

  // Write env file with restricted permissions (600 = owner read/write only)
  await writeFile(envPath, envContent, { mode: 0o600 });
}

/**
 * Read tunnel configuration from .env file if it exists
 */
export async function readTunnelConfig(): Promise<TunnelConfig | null> {
  const envPath = join(DOCKER_DIR, ".env");

  if (!existsSync(envPath)) {
    return null;
  }

  const content = await readFile(envPath, "utf-8");
  const lines = content.split("\n");

  const config: Partial<TunnelConfig> = {};

  for (const line of lines) {
    const [key, ...valueParts] = line.split("=");
    const value = valueParts.join("="); // Handle values with = in them

    if (key === "CLOUDFLARE_API_TOKEN") config.apiToken = value;
    if (key === "CLOUDFLARE_ACCOUNT_ID") config.accountId = value;
    if (key === "CLOUDFLARE_ZONE_ID") config.zoneId = value;
    if (key === "CLOUDFLARE_ZONE_NAME") config.zoneName = value;
    if (key === "CLOUDFLARE_TUNNEL_ID") config.tunnelId = value;
    if (key === "CLOUDFLARE_TUNNEL_NAME") config.tunnelName = value;
    if (key === "CLOUDFLARE_TUNNEL_TOKEN") config.tunnelToken = value;
    if (key === "CLOUDFLARE_HOSTNAME") config.hostname = value;
    if (key === "CLOUDFLARE_DNS_RECORD_ID") config.dnsRecordId = value;
  }

  // Check if we have all required tunnel config fields
  if (
    config.apiToken &&
    config.accountId &&
    config.zoneId &&
    config.zoneName &&
    config.tunnelId &&
    config.tunnelName &&
    config.tunnelToken &&
    config.hostname &&
    config.dnsRecordId
  ) {
    return config as TunnelConfig;
  }

  return null;
}

/**
 * Check if tunnel is configured
 */
export async function tunnelConfigExists(): Promise<boolean> {
  const config = await readTunnelConfig();
  return config !== null;
}

/**
 * Copy docker-compose.yml template with tunnel profile enabled
 */
export async function copyDockerComposeWithTunnel(): Promise<void> {
  const templatePath = join(TEMPLATE_DIR, "docker-compose.yml");
  const targetPath = join(DOCKER_DIR, "docker-compose.yml");

  // Ensure directory exists
  await mkdir(DOCKER_DIR, { recursive: true });

  // Read the template
  let content = await readFile(templatePath, "utf-8");

  // Enable the tunnel profile by removing the profiles section from cloudflared
  // This makes cloudflared always start when tunnel is configured
  content = content.replace(
    /profiles:\s*\n\s*- tunnel\s*# Only started when tunnel is configured/g,
    "# Tunnel profile enabled",
  );

  await writeFile(targetPath, content);
}

/**
 * Update existing config with tunnel settings (preserves encryption key)
 */
export function createTunnelConfigFromExisting(
  existingConfig: N8nConfig,
  hostname: string,
): N8nConfig {
  return {
    encryptionKey: existingConfig.encryptionKey, // Preserve existing key
    host: hostname,
    port: existingConfig.port,
    protocol: existingConfig.protocol,
    webhookUrl: `https://${hostname}/`,
  };
}
